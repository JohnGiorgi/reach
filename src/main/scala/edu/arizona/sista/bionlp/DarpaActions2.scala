package edu.arizona.sista.bionlp

import edu.arizona.sista.odin._
import edu.arizona.sista.bionlp.mentions._
import edu.arizona.sista.struct.Interval

class DarpaActions2 extends Actions {

  /** Converts mentions to biomentions.
    * They are returned as mentions but they are biomentions with grounding, modifications, etc
    */
  def mkBioMention(mentions: Seq[Mention], state: State): Seq[Mention] =
    mentions.map(_.toBioMention)

  // FIXME delete this
  override val default: Action = mkBioMention

  /** Unpacks RelationMentions into its arguments. A new BioTextBoundMention
    * will be created for each argument with the labels of the original RelationMention.
    * This is relying on Odin's behavior of assigning the same label of the RelationMention
    * to its arguments captured with a pattern (not mention captures).
    * This is required for RelationMentions whose arguments are used directly
    * by subsequent rules.
    * WARNING This method only handles RelationMentions. Other types of Mentions are deleted.
    */
  // FIXME rename to unpackRelation()
  def unpackRelations(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case rel: RelationMention => for {
      (k, v) <- rel.arguments
      m <- v
    } yield m.toBioMention
    case _ => Nil
  }

  val mkEntities: Action = unpackRelations

  /** This action handles the creation of mentions from labels generated by the NER system.
    * Rules that use this action should run in an iteration following and rules recognizing
    * "custom" entities. This action will only create mentions if no other mentions overlap
    * with a NER label sequence.
    */
  def mkNERMentions(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap { m =>
      val candidates = state.mentionsFor(m.sentence, m.tokenInterval.toSeq)
      // do any candidates overlap the mention?
      val overlap = candidates.exists(_.tokenInterval.overlaps(m.tokenInterval))
      if (overlap) None else Some(m.toBioMention)
    }
  }

  // FIXME change modification_trigger_1 to return a textboundmention
  // instead of implementing mkModTrigger()

  /** This action gets RelationMentions that represents a PTM,
    * and attaches the modification to the target entity in place.
    * This action modifies mentions in-place. This action always returns
    * Nil, it assumes that the arguments are already in the state.
    */
  def storeModification(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions foreach {
      case ptm: RelationMention if ptm matches "PTM" =>
        // convert first relation("entity") into BioMention
        val bioMention = ptm.arguments("entity").head.toBioMention
        // retrieve optional first relation("site")
        val site = ptm.arguments.get("site").map(_.head)
        // retrieves first relation("mod")
        // this is the TextBoundMention for the ModifcationTrigger
        val evidence = ptm.arguments("mod").head
        // assigns label from mod
        val label = getModificationLabel(evidence.text)
        // if label is not unknown then add PTM modification to entity in-place
        if (label != "UNKNOWN") bioMention.modifications += PTM(label, Some(evidence), site)
      case _ => ()
    }
    // this action never returns anything
    // mutates mentions in-place
    // :(
    Nil
  }

  /** Gets RelationMentions that represent an EventSite,
    * and attaches the site to the corresponding event in-place.
    * This action always returns Nil and assumes that the arguments are already
    * in the state.
    */
  // FIXME modify rules: eventsite_multisite_1, eventsite_withparens to capture all sites
  def storeEventSite(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions foreach {
      case es: RelationMention if es matches "EventSite" =>
        // convert first relation("entity") into BioMention
        val bioMention = es.arguments("entity").head.toBioMention
        // retrieves all the captured sites
        val sites = es.arguments("site")
        sites foreach { s =>
          bioMention.modifications += EventSite(site = s)
        }
      case _ => ()
    }
    Nil
  }

  def storeMutants(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions foreach {
      case m: RelationMention if m matches "Mutant" =>
        val bioMention = m.arguments("entity").head.toBioMention
        val mutants = m.arguments("mutant")
        mutants foreach { mutant =>
            bioMention.modifications += Mutant(evidence = mutant)
        }
    }
    Nil
  }

  // helper functions

  // retrieve the appropriate modification label
  def getModificationLabel(text: String): String = text.toLowerCase match {
    case string if string contains "acetylat" => "acetylated"
    case string if string contains "farnesylat" => "farnesylated"
    case string if string contains "glycosylat" =>"glycosylated"
    case string if string contains "hydroxylat" =>"hydroxylated"
    case string if string contains "methylat" => "methylated"
    case string if string contains "phosphorylat" => "phosphorylated"
    case string if string contains "ribosylat" => "ribosylated"
    case string if string contains "sumoylat" =>"sumoylated"
    case string if string contains "ubiquitinat" => "ubiquitinated"
    case _ => "UNKNOWN"
  }

}
