package edu.arizona.sista.bionlp

import edu.arizona.sista.odin._
import edu.arizona.sista.bionlp.mentions._

class DarpaActions2 extends Actions {

  /** Converts mentions to biomentions.
    * They are returned as mentions but they are biomentions with grounding, modifications, etc
    */
  def mkBioMention(mentions: Seq[Mention], state: State): Seq[Mention] =
    mentions.map(_.toBioMention)

  // FIXME delete this
  override val default: Action = mkBioMention

  /** Unpacks RelationMentions into its arguments. A new BioTextBoundMention
    * will be created for each argument with the labels of the original RelationMention.
    * This is relying on Odin's behavior of assigning the same label of the RelationMention
    * to its arguments captured with a pattern (not mention captures).
    * This is required for RelationMentions whose arguments are used directly
    * by subsequent rules.
    * WARNING This method only handles RelationMentions. Other types of Mentions are deleted.
    */
  // FIXME rename to unpackRelation()
  def mkEntities(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case rel: RelationMention => for {
      (k, v) <- rel.arguments
      m <- v
    } yield m.toBioMention
    case _ => Nil
  }

  /** This action handles the creation of mentions from labels generated by the NER system.
    * Rules that use this action should run in an iteration following and rules recognizing
    * "custom" entities. This action will only create mentions if no other mentions overlap
    * with a NER label sequence.
    */
  def mkNERMentions(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap { m =>
      val candidates = state.mentionsFor(m.sentence, m.tokenInterval.toSeq)
      // do any candidates overlap the mention?
      val overlap = candidates.exists(_.tokenInterval.overlaps(m.tokenInterval))
      if (overlap) None else Some(m.toBioMention)
    }
  }



}
