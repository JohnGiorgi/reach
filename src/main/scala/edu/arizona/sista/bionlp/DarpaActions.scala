package edu.arizona.sista.bionlp

import edu.arizona.sista.processors.Document
import edu.arizona.sista.struct.Interval
import edu.arizona.sista.odin._
import edu.arizona.sista.bionlp.mentions._

class DarpaActions extends Actions {

  def splitSimpleEvents(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case m: EventMention if m matches "SimpleEvent" =>
      // Do we have a regulation?
      if (m.arguments.keySet contains "cause") {
        // FIXME There could be more than one cause...
        val cause:Seq[Mention] = m.arguments("cause")
        val evArgs = m.arguments - "cause"
        val ev = new BioEventMention(
          m.labels, m.trigger, evArgs, m.sentence, m.document, m.keep, m.foundBy)
        // make sure the regulation is valid
        val controlledArgs:Set[Mention] = evArgs.values.flatten.toSet
          cause match {
          // controller of an event should not be an arg in the controlled
          case reg if cause.forall(c => !controlledArgs.contains(c)) => {
            val regArgs = Map("controlled" -> Seq(ev), "controller" -> cause)
            val reg = new BioRelationMention(
              Seq("Positive_regulation", "ComplexEvent", "Event"),
              regArgs, m.sentence, m.document, m.keep, m.foundBy)
            Seq(reg, ev)
          }
          case _ => Nil
        }
      } else Seq(m.toBioMention)
    case m => Seq(m.toBioMention)
  }

  def mkEntities(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case rel: RelationMention => {
      for {(k, v) <- rel.arguments
           m <- v} yield {
        new TextBoundMention(rel.labels, m.tokenInterval, rel.sentence, rel.document, rel.keep, rel.foundBy).toBioMention
      }
    }
      case other => {
        Nil
    }
  }
  // FIXME it would be better to define the action explicitly in the rule
  // instead of replacing the default action
  override val default: Action = splitSimpleEvents

  /** This action handles the creation of mentions from labels generated by the NER system.
    * Rules that use this action should run in an iteration following and rules recognizing
    * "custom" entities. This action will only create mentions if no other mentions overlap
    * with a NER label sequence.
    */
  def mkNERMentions(mentions: Seq[Mention], state: State): Seq[Mention] = {
    mentions flatMap { m =>
      val candidates = state.mentionsFor(m.sentence, m.tokenInterval.toSeq)
      // do any candidates intersect the mention?
      val overlap = candidates.exists(_.tokenInterval.overlaps(m.tokenInterval))
      if (overlap) None else Some(m.toBioMention)
    }
  }

  /** This action handles the creation of ubiquitination EventMentions.
    * A Ubiquitination event cannot involve arguments (theme/cause) with the text Ubiquitin.
    */
  def mkUbiquitination(mentions: Seq[Mention], state: State): Seq[Mention] = {
    val filteredMentions = mentions.filter { m =>
      // Don't allow Ubiquitin
      !m.arguments.values.flatten.exists(_.text.toLowerCase.startsWith("ubiq")) 
    }
    val bioMentions = filteredMentions.map(_.toBioMention)
    // TODO: a temporary hack to convert theme+cause ubiqs => regs
    splitSimpleEvents(bioMentions, state)
  }

  /** This action handles the creation of Binding EventMentions for rules using token patterns.
    * Currently Odin does not support the use of arguments of the same name in Token patterns.
    * Because of this, we have adopted the convention of following duplicate names with a
    * unique number (ex. theme1, theme2).
    * mkBinding simply unifies named arguments of this type (ex. theme1 & theme2 -> theme)
    */
  def mkBinding(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case m: EventMention =>
      val arguments = m.arguments
      val themes = for {
        name <- arguments.keys.toSeq
        if name startsWith "theme"
        theme <- arguments(name)
      } yield theme
      // remove bindings with less than two themes
      if (themes.size < 2) Nil
      // if binding has two (distinct) themes we are done
      else if (themes.size == 2 && !sameEntityID(themes)) {
        val args = Map("theme" -> themes)
        Seq(new BioEventMention(
          m.labels, m.trigger, args, m.sentence, m.document, m.keep, m.foundBy))
      } else {
        // binarize bindings
        // return bindings with pairs of themes
        for (pair <- themes.combinations(2)
        //if themes are not the same entity
             if ! sameEntityID(pair)) yield {
          val args = Map("theme" -> pair)
          new BioEventMention(m.labels, m.trigger, args, m.sentence, m.document, m.keep, m.foundBy)
        }
      }
  }

  /**
   * Do we have exactly 1 unique grounding id for this Sequence of Mentions?
   * @param mentions A Sequence of odin-style mentions
   * @return boolean
   */
  def sameEntityID(mentions:Seq[Mention]): Boolean = {
    val groundings =
      mentions
      .map(_.toBioMention)
      // only look at grounded Mentions
      .filter(_.xref.isDefined)
      .map(_.xref.get)
      .toSet
    // should be 1 if all are the same entity
    groundings.size == 1
  }
  /**
   * This action decomposes RelationMentions with the label Modification to the matched TB entity with the appropriate Modification
   * @return Nil (Modifications are added in-place)
   */
  def mkModification(mentions: Seq[Mention], state: State): Seq[Mention] = {
    // retrieve the appropriate modification label
    def getModification(text: String): String = text.toLowerCase match {
      case acet if acet contains "acetylat" => "acetylated"
      case farne if farne contains "farnesylat" => "farnesylated"
      case glyco if glyco contains "glycosylat" =>"glycosylated"
      case hydrox if hydrox contains "hydroxylat" =>"hydroxylated"
      case meth if meth contains "methylat" => "methylated"
      case phos if phos contains "phosphorylat" => "phosphorylated"
      case ribo if ribo contains "ribosylat" => "ribosylated"
      case sumo if sumo contains "sumoylat" =>"sumoylated"
      case ubiq if ubiq contains "ubiquitinat" => "ubiquitinated"
      case _ => "UNKNOWN"
    }

    mentions flatMap {
      case ptm: RelationMention if ptm.label == "PTM" => {
        //println("found a modification...")
        val trigger = ptm.arguments("mod").head
        // If this creates a new mention, we have a bug because it won't end up in the State
        val bioMention = ptm.arguments("entity").head.toBioMention
        val site = if (ptm.arguments.keySet.contains("site")) Some(ptm.arguments("site").head) else None
        // This is the TextBoundMention for the ModifcationTrigger
        val evidence = ptm.arguments("mod").head
        val label = getModification(evidence.text)
        // If we have a label, add the modification in-place
        if (label != "UNKNOWN") bioMention.modifications += PTM(label, Some(evidence), site)
        Nil // don't return anything; this mention is already in the State
      }
    }
  }

  /**
   * Sometimes it's easiest to find the site associated with a BioChemicalEntity before event detection
   * @return Nil (Modifications are added in-place)
   */
  def storeEventSite(mentions: Seq[Mention], state: State): Seq[Mention] = {
    //println(s"\tcreating EventSite!")
    mentions foreach { m =>
      val bioMention = m.arguments("entity").head.toBioMention
      // Check the complete span for any sites
      // FIXME this is due to an odin bug
      state.mentionsFor(m.sentence, m.tokenInterval.toSeq, "Site") foreach { eSite =>
        println(s"\tEventSite Modification detected: site is ${eSite.text} for ${bioMention.text}")
        bioMention.modifications += EventSite(site = eSite)
      }
    }
    Nil
  }

  /**
   * Global action for events.  Propagate any Sites in the Modifications of a a SimpleEvent's theme to the event arguments
   */
  def siteSniffer(mentions: Seq[Mention], state: State): Seq[Mention] = mentions flatMap {
    case simple: EventMention if simple.labels contains "SimpleEvent" => {
      val additionalSites: Seq[Mention] = simple.arguments.values.flatten.flatMap { case m:BioMention =>
        // get the sites from any EventSite Modifications
        val eventSites:Seq[EventSite] = m.modifications.toSeq flatMap {
          case es:EventSite => Some(es)
          case _ => None
        }
        // Remove EventSite modifications
        eventSites.foreach(es => m.modifications -= es)

        // Get additional sites
        eventSites.map{case es: EventSite => es.site}
      }.toSeq

      // Gather up our sites
      val allSites = additionalSites ++ simple.arguments.getOrElse("site", Nil)

      // Do we have any sites?
      if (allSites.isEmpty) Seq(simple)
      else {
        val allButSite = simple.arguments - "site"
        // Create a separate EventMention for each Site
        for (site <- allSites.distinct) yield {
          val updatedArgs = allButSite + ("site" -> Seq(site))
          // FIXME the interval might not be correct anymore...
          new EventMention(simple.labels,
            simple.trigger,
            updatedArgs,
            simple.sentence,
            simple.document,
            simple.keep,
            simple.foundBy).toBioMention
        }
      }
    }
    // If it isn't a SimpleEvent, assume there is nothing more to do
    case m => Seq(m)
  }
}
