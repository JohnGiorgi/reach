#
# Configuration file for reach-assembly
#

# number of simultaneous threads to use for parallelization
#threadLimit = 2

# settings for assembly
assembly {
  # assembly can be run directly over a directory of papers (see ReachCLI) set by the papersDir property
  #
  # assembly output (outDir) is in the form of json or tsv files:
  #
  # TSV-style output
  # Currently, two tsv files are produced for each paper:
  # 1. assembly matching MITRE's (March 2016) requirements
  # 2. unconstrained
  #
  # Additionally, two output files are produced to show assembly across all papers:
  # 1. assembly matching MITRE's (March 2016) requirements
  # 2. unconstrained

  # consider pairs of mentions within N sentences of one another
  windowSize = 1

  corpus {
    # mentions with these labels may form an annotation pair
    validLabels = ["ComplexEvent", "Binding"]
    # a relation corpus (json)
    corpusDir = ${HOME}/Downloads/causal-assembly
    # directory of json files (doc + mentions)
    jsonDir = ${HOME}/Downloads/causal-assembly/mention-data

    constraints {
      # the minimum number of equiv event pairs needed per paper
      # for inclusion of the event pair in the corpus
      minSeen = 2
      # PMIDs included in the train partition of the assembly corpus.
      # The test partition of the corpus should be built from different papers
      skip = ["PMC1242134", "PMC1681468", "PMC2064341", "PMC2173502", "PMC2194160", "PMC2254474", "PMC2409554", "PMC2475507", "PMC2533353", "PMC2570545", "PMC2586335", "PMC2652403", "PMC2671034", "PMC2683723", "PMC2686094", "PMC2695278", "PMC2721311", "PMC2796463", "PMC2808051", "PMC2836960", "PMC2848644", "PMC2893101", "PMC3003658", "PMC3005813", "PMC3045384", "PMC3064594", "PMC3068163", "PMC3116122", "PMC3134378", "PMC3161675", "PMC3166778", "PMC3215182", "PMC3219189", "PMC3246894", "PMC3269678", "PMC3270275", "PMC3270278", "PMC3289391", "PMC3295902", "PMC3296207", "PMC3312193", "PMC3321461", "PMC3327327", "PMC3330700", "PMC3351432", "PMC3355968", "PMC3357561", "PMC3391878", "PMC3416861", "PMC3441633", "PMC3444108", "PMC3461631", "PMC3490961", "PMC3504475", "PMC3510844", "PMC3533183", "PMC3539672", "PMC3563485", "PMC3585432", "PMC3587337", "PMC3605509", "PMC3640382", "PMC3660063", "PMC3663556", "PMC3676797", "PMC3733026", "PMC3804542", "PMC3822826", "PMC3835109", "PMC3844392", "PMC3844930", "PMC3877845", "PMC3885983", "PMC3887408", "PMC3901111", "PMC3920945", "PMC3936289", "PMC3941061", "PMC3958334", "PMC4002725", "PMC4021559", "PMC4055838", "PMC4074803", "PMC4102778", "PMC4113681", "PMC4132442", "PMC4151135", "PMC4155833", "PMC4158873", "PMC4163293", "PMC4189854", "PMC4202120", "PMC4203326", "PMC4207485", "PMC4237825", "PMC4264134", "PMC4327825", "PMC4349922", "PMC4373087", "PMC4377201", "PMC4381250", "PMC4391485", "PMC4407294", "PMC4422219", "PMC4423074", "PMC4431608"]
    }
  }

  # assembly relation classifier
  classifier {

    # what algorithm to use?
    classifier = lin-svm-l1

    # the trained model file (for reading and writing)
    # NOTE: do not put a leading slash.
    # This is loaded from the class path by the classLoader
    model = org/clulab/reach/assembly/fbc.model # this is a lin-svm-l1 model

    # report of results
    results = results.tsv
  }

  # serialized gold PrecedenceRelations for evaluation
  evalGold = evalGold.ser

  # serialized mentions prior to applying rule-based sieves
  evalMentions = evalMentions.ser

  # allow additional information output
  verbose = true
}


akka {
  # Log the complete configuration at INFO level when the actor system is started.
  # This is useful when you are uncertain of what configuration is used.
  #log-config-on-start = on
  # http://rerun.me/2014/09/29/akka-notes-logging-and-testing/
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
  #loglevel = OFF
  loglevel = DEBUG
  #stdout-loglevel = OFF
  log-dead-letters = OFF
  //io.TcpListener = DEBUG

  http {
    server {
      port = 8888
      host = localhost # 0.0.0.0
      # The time after which an idle connection will be automatically closed.
      # Set to `infinite` to completely disable idle connection timeouts.
      idle-timeout = 20 minutes

      # The time period within which the TCP binding process must be completed.
      # Set to `infinite` to disable.
      bind-timeout = 1s
      request-timeout = 10 minutes
    }

    client {
      # The time after which an idle connection will be automatically closed.
      # Set to `infinite` to completely disable idle timeouts.
      idle-timeout = 20 minutes

    }
  }
}